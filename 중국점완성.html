<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="theme-color" content="#151924" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="중국점" />
<link rel="manifest" href="manifest.json" />
<link rel="apple-touch-icon" href="icon-192.png" />
<title>중국점 분석기 - 바카라 도구</title>
<style>
  :root {
    --bg:#0f1115; --panel:#151924; --text:#e6e6e6; --muted:#9aa3b2;
    --banker:#e74c3c; --player:#3498db; --red:#e74c3c; --blue:#3aa4ff;
    --cell-base:24px;
    --ui-scale:1;
    --cell:calc(var(--cell-base) * var(--ui-scale));
    --gap:calc(6px * var(--ui-scale));
    --font-base:14px;
  }
  body { 
    margin:0; 
    background:var(--bg); 
    color:var(--text); 
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; 
    font-size:var(--font-base);
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  .wrap { 
    display:grid; 
    grid-template-columns:450px 1fr; 
    gap:16px; 
    padding:16px;
    min-width: 1200px;
  }
  
  /* 모바일 반응형 */
  @media (max-width: 768px) {
    .wrap {
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 8px;
      min-width: auto;
    }
    .panel {
      padding: 8px;
    }
    .controls {
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }
    button {
      padding: 6px 8px;
      font-size: 12px;
    }
    .scale-buttons {
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
    }
    .top-row, .bigeye-row {
      flex-direction: column;
      gap: 8px;
    }
    .top-row .panel, .bigeye-row .panel {
      flex: none;
    }
    h3 {
      font-size: 0.9em;
    }
    .legend {
      font-size: 0.8em;
      gap: 8px;
    }
    .footer {
      font-size: 1em;
    }
  }
  .panel { background:var(--panel); border-radius:10px; padding:12px; box-shadow:0 0 0 1px #1f2533 inset, 0 8px 24px rgba(0,0,0,.3); }
  .controls { display:grid; grid-template-columns:repeat(5,1fr); gap:8px; margin-bottom:10px; }
  button { background:#1b2130; color:var(--text); border:1px solid #2a3448; border-radius:8px; padding:8px 10px; cursor:pointer; font-weight:700; }
  button:hover { filter:brightness(1.1); }
  .b { background:var(--banker); border:none; }
  .p { background:var(--player); border:none; }
  h3 { margin:8px 0 10px; font-size:1em; color:var(--muted); font-weight:800; letter-spacing:.08em; text-transform:uppercase; }

  /* Right board container that scales independently */
  #board { --ui-scale:1; --cell:calc(var(--cell-base) * var(--ui-scale)); --gap:calc(6px * var(--ui-scale)); }
  .board { display:grid; gap:12px; }

  .grid { display:grid; gap:var(--gap); grid-auto-flow:column; grid-auto-columns:min-content; }
  .col { display:grid; gap:var(--gap); }

  .cell { width:var(--cell); height:var(--cell); border:2px solid #3a4661; border-radius:50%; position:relative; background:transparent; }
  .fill-b { background:transparent; border-color:var(--banker); border-width:3px; }
  .fill-p { background:transparent; border-color:var(--player); border-width:3px; }

  .dcell { width:var(--cell); height:var(--cell); border-radius:50%; position:relative; border:2px solid #3a4661; }
  .d-red { border-color:var(--red); }
  .d-blue { border-color:var(--blue); }
  .dcell::after { content:""; position:absolute; inset:calc(6px * var(--ui-scale)); border-radius:50%; }
  .d-red::after { background:var(--red); }
  .d-blue::after { background:var(--blue); }

  /* 구분선 스타일 */
  .row-divider { 
    height: 2px; 
    background: rgba(255, 255, 255, 0.3); 
    margin: 0; 
    border-radius: 1px; 
  }

  .legend { display:flex; flex-wrap:wrap; gap:12px; font-size:0.9em; color:var(--muted); }
  .dot { width:10px; height:10px; border-radius:50%; display:inline-block; margin-right:6px; }
  .footer { margin-top:8px; font-size:1.2em; color:var(--muted); font-weight:700; }
  .scale-buttons { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:8px; }

  /* Prediction panel */
  .pred { margin:10px 0; padding:10px; background:#111724; border:1px solid #2a3448; border-radius:8px; display:grid; gap:8px; }
  .pred h4 { margin:0; font-size:1em; color:var(--muted); }
  .pred-row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .badge { padding:2px 8px; border-radius:6px; font-weight:700; border:1px solid #2a3448; }
  .badge.p { background:var(--player); color:#fff; border:none; }
  .badge.b { background:var(--banker); color:#fff; border:none; }
  .pdot { width:12px; height:12px; border-radius:50%; display:inline-block; margin-left:6px; border:2px solid #2a3448; }
  .pred-arrow { font-size:16px; font-weight:900; line-height:1; margin-left:4px; }

  /* Pattern analysis panel */
  .pattern { margin:10px 0; padding:10px; background:#111724; border:1px solid #2a3448; border-radius:8px; display:grid; gap:8px; }
  .pattern h4 { margin:0; font-size:1em; color:var(--muted); }
  .pattern-row { display:flex; align-items:center; justify-content:space-between; gap:12px; }
  .pattern-label { color:var(--muted); font-weight:700; min-width:80px; }
  .arrow { font-size:22px; font-weight:900; line-height:1; }
  
  /* 패턴분석2창의 정렬을 위한 스타일 */
  .pattern-row { display:flex; align-items:center; gap:12px; }
  .pattern-row .pattern-label { min-width:100px; }
  .pattern-row .prediction-badge { min-width:25px; text-align:center; flex-shrink:0; padding:2px 6px; font-size:0.9em; }
  .pattern-row .pattern-info { min-width:140px; text-align:left; font-weight:800; }
  
  /* % 부분을 진하게 표시하는 스타일 */
  .percentage-bold { font-weight:900; color:#fff; }

  /* Prediction result panel */
  .prediction-result { margin:10px 0; padding:10px; background:#111724; border:1px solid #2a3448; border-radius:8px; display:grid; gap:8px; }
  .prediction-result h4 { margin:0; font-size:1em; color:var(--muted); }
  .prediction-badge { padding:4px 12px; border-radius:6px; font-weight:700; font-size:1.1em; text-align:center; min-width:40px; }
  .prediction-badge.p { background:var(--blue); color:#fff; }
  .prediction-badge.b { background:var(--red); color:#fff; }
  .prediction-badge.neutral { background:#2a3448; color:var(--muted); }
  
  /* 패턴분석2창과 예측값2창 사이의 간격 조정 */
  .prediction-result:nth-of-type(4) { margin-bottom:20px; } /* 패턴분석2창 */
  .prediction-result:nth-of-type(5) { margin-top:5px; } /* 예측값2창 */
  
  /* 새로운 예측값창용 색상 (B=빨간색, P=파란색) */
  #pred_value_display.p { background:var(--blue); color:#fff; }
  #pred_value_display.b { background:var(--red); color:#fff; }
  .pattern-info { color:var(--muted); font-size:0.9em; margin-bottom:8px; }

  /* OX panel */
  .ox-panel { margin:10px 0; padding:10px; background:#111724; border:1px solid #2a3448; border-radius:8px; }
  .ox-grid { display:grid; gap:var(--gap); grid-auto-flow:column; grid-auto-columns:min-content; }
  .ox-col { display:grid; gap:var(--gap); }
  .ox-cell { width:var(--cell); height:var(--cell); border:2px solid #3a4661; border-radius:50%; position:relative; background:transparent; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; font-size:14px; }
  .ox-cell.o { background:var(--player); border-color:var(--player); color:#fff; }
  .ox-cell.x { background:var(--banker); border-color:var(--banker); color:#fff; }
  .ox-cell:hover { filter:brightness(1.2); }

  /* Row layouts */
  .top-row { display:flex; gap:12px; }
  .top-row .panel { flex:1; }
  .bigeye-row { display:flex; gap:12px; }
  .bigeye-row .panel { flex:1; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="controls">
        <button class="b" onclick="add('B')">B</button>
        <button class="p" onclick="add('P')">P</button>
        <button onclick="undo()">Undo</button>
        <button onclick="resetAll()">Reset</button>
        <button onclick="toggleDerivedMeaning()">빨/파 전환</button>
      </div>
      <div class="scale-buttons">
        <button onclick="setScale(1)">100%</button>
        <button onclick="setScale(0.5)">50%</button>
        <button onclick="setScale(0.33)">33%</button>
      </div>
      
      <div class="scale-buttons">
        <button onclick="toggleOriginalPanels()" id="toggle_btn">기존창 숨기기</button>
      </div>

      <div class="pred" id="original_pred">
        <h4>다음값 예상</h4>
        <div class="pred-row">
          <button type="button" class="badge p">Next P</button>
          <span>Big Eye:<span id="predP_be_dot" class="pdot"></span><span id="predP_be_arrow" class="pred-arrow"></span></span>
          <span>Small:<span id="predP_sm_dot" class="pdot"></span><span id="predP_sm_arrow" class="pred-arrow"></span></span>
          <span>Cockroach:<span id="predP_ck_dot" class="pdot"></span><span id="predP_ck_arrow" class="pred-arrow"></span></span>
        </div>
        <div class="pred-row">
          <button type="button" class="badge b">Next B</button>
          <span>Big Eye:<span id="predB_be_dot" class="pdot"></span><span id="predB_be_arrow" class="pred-arrow"></span></span>
          <span>Small:<span id="predB_sm_dot" class="pdot"></span><span id="predB_sm_arrow" class="pred-arrow"></span></span>
          <span>Cockroach:<span id="predB_ck_dot" class="pdot"></span><span id="predB_ck_arrow" class="pred-arrow"></span></span>
        </div>
      </div>


      <!-- 새로운 예측창 추가 -->
      <div class="prediction-result" id="original_prediction_result">
        <h4>예측 결과</h4>
        <div class="pattern-info" id="pattern_info">패턴 분석 중...</div>
      </div>

      <!-- 새로운 예측값창 추가 -->
      <div class="prediction-result" id="original_prediction_value">
        <h4>예측값</h4>
        <div class="pred-row" style="display: flex; justify-content: space-between; align-items: center;">
          <div style="display: flex; align-items: center;">
            <span class="pattern-label">예측값:</span>
            <span id="pred_value_display" class="prediction-badge" style="margin-left: 5px;">-</span>
          </div>
          <span id="prediction_stats" class="prediction-badge neutral" style="font-size: 0.85em;">총:0 O:0 X:0 (0%)</span>
        </div>
      </div>


          <!-- 예측값2 통계창 추가 -->
          <div class="prediction-result">
            <h4>예측값2 통계</h4>
            <div class="pattern-row">
              <span class="pattern-label">2-1:3개일치</span>
              <span id="stats2_1_display" class="prediction-badge neutral">-</span>
            </div>
            <div class="pattern-row">
              <span class="pattern-label">2-2:2개일치</span>
              <span id="stats2_2_display" class="prediction-badge neutral">-</span>
            </div>
          </div>

          <!-- 그림방향통계창 추가 -->
          <div class="prediction-result">
            <h4>그림방향통계</h4>
            <div class="pattern-row">
              <span class="pattern-label">그림방향종합</span>
              <span id="direction_summary_stats_display" class="prediction-badge neutral">-</span>
            </div>
          </div>


      <!-- 예측값2-1창 추가 -->
      <div class="prediction-result">
        <h4>예측값2-1 (3개 일치)</h4>
        <div class="pattern-info" id="prediction2_1_info">색상 비교 중...</div>
        <div class="pred-row">
          <span class="pattern-label">예측값:</span>
          <span id="pred_value2_1_display" class="prediction-badge neutral">-</span>
        </div>
      </div>

      <!-- 예측값2-2창 추가 -->
      <div class="prediction-result">
        <h4>예측값2-2 (2개 이상)</h4>
        <div class="pattern-info" id="prediction2_2_info">색상 비교 중...</div>
        <div class="pred-row">
          <span class="pattern-label">예측값:</span>
          <span id="pred_value2_2_display" class="prediction-badge neutral">-</span>
        </div>
      </div>

      <div class="pattern" id="original_pattern">
        <h4>패턴 분석</h4>
        <div class="pattern-row">
          <span class="pattern-label">Big Eye</span>
          <span id="ptr_be" class="arrow">-</span>
        </div>
        <div class="pattern-row">
          <span class="pattern-label">Small Road</span>
          <span id="ptr_sm" class="arrow">-</span>
        </div>
        <div class="pattern-row">
          <span class="pattern-label">Cockroach Pig</span>
          <span id="ptr_ck" class="arrow">-</span>
        </div>
      </div>

      <!-- 패턴분석2창 추가 -->
      <div class="prediction-result">
        <h4>패턴분석2</h4>
        <div class="pattern-row">
          <span class="pattern-label">Big Eye</span>
          <span id="current_color_be" class="prediction-badge neutral">-</span>
          <span id="pattern2_be_count" class="pattern-info" style="margin-left: 10px; font-size: 0.9em;"></span>
        </div>
        <div class="pattern-row">
          <span class="pattern-label">Small Road</span>
          <span id="current_color_sm" class="prediction-badge neutral">-</span>
          <span id="pattern2_sm_count" class="pattern-info" style="margin-left: 10px; font-size: 0.9em;"></span>
        </div>
        <div class="pattern-row">
          <span class="pattern-label">Cockroach Pig</span>
          <span id="current_color_ck" class="prediction-badge neutral">-</span>
          <span id="pattern2_ck_count" class="pattern-info" style="margin-left: 10px; font-size: 0.9em;"></span>
        </div>
      </div>

      <!-- 예측값2-3창 추가 (숨김) -->
      <div class="prediction-result" style="display: none;">
        <h4>예측값2-3 (빨간색 2개 이상)</h4>
        <div class="pattern-info" id="prediction2_3_info">색상 비교 중...</div>
        <div class="pred-row">
          <span class="pattern-label">예측값:</span>
          <span id="pred_value2_3_display" class="prediction-badge neutral">-</span>
        </div>
      </div>

      <!-- 예측값2-4창 추가 (숨김) -->
      <div class="prediction-result" style="display: none;">
        <h4>예측값2-4 (파란색 2개 이상)</h4>
        <div class="pattern-info" id="prediction2_4_info">색상 비교 중...</div>
        <div class="pred-row">
          <span class="pattern-label">예측값:</span>
          <span id="pred_value2_4_display" class="prediction-badge neutral">-</span>
        </div>
      </div>


      <div class="legend">
        <span><span class="dot" style="background:var(--banker)"></span>Banker</span>
        <span><span class="dot" style="background:var(--player)"></span>Player</span>
        <span><span class="dot" style="background:var(--red)"></span>Red(긍정)</span>
        <span><span class="dot" style="background:var(--blue)"></span>Blue(부정)</span>
      </div>
      <div id="count" class="footer"></div>
    </div>

    <div id="board" class="board">
      <!-- Top row with Big Road and O/X -->
      <div class="top-row">
        <div class="panel">
          <h3>Big Road (20 rows) - <span id="bigroad_count"></span></h3>
          <div id="bigroad" class="grid"></div>
        </div>
        <div class="panel">
          <h3>O 창 (20 rows) - <span id="o_count"></span></h3>
          <div id="o_grid" class="ox-grid"></div>
        </div>
        <div class="panel">
          <h3>X 창 (20 rows) - <span id="x_count"></span></h3>
          <div id="x_grid" class="ox-grid"></div>
        </div>
      </div>
      
      <!-- Big Eye row -->
      <div class="bigeye-row">
        <div class="panel">
          <h3>Big Eye (20 rows) - <span id="bigeye_count"></span></h3>
          <div id="bigeye" class="grid"></div>
        </div>
        <div class="panel">
          <h3>OX TOTAL 그림예측 (20 rows) - <span id="ox_total_count"></span></h3>
          <div id="ox_total_grid" class="ox-grid"></div>
        </div>
      </div>
      
      <!-- Small Road와 OX TOTAL 방향예측값 O/X창을 나란히 배치 -->
      <div class="top-row">
        <div class="panel">
          <h3>Small Road (20 rows) - <span id="smallroad_count"></span></h3>
          <div id="smallroad" class="grid"></div>
        </div>
        <div class="panel">
          <h3>방향예측값 O 창 (20 rows) - <span id="direction_o_count"></span></h3>
          <div id="direction_o_grid" class="ox-grid"></div>
        </div>
        <div class="panel">
          <h3>방향예측값 X 창 (20 rows) - <span id="direction_x_count"></span></h3>
          <div id="direction_x_grid" class="ox-grid"></div>
        </div>
      </div>
      <!-- Cockroach Pig와 OX TOTAL 방향예측값을 나란히 배치 -->
      <div class="bigeye-row">
        <div class="panel">
          <h3>Cockroach Pig (20 rows) - <span id="cockroach_count"></span></h3>
          <div id="cockroach" class="grid"></div>
        </div>
        <div class="panel">
          <h3>OX TOTAL 방향예측값 (20 rows) - <span id="ox_direction_count"></span></h3>
          <div id="ox_direction_grid" class="ox-grid"></div>
        </div>
      </div>
      
      <!-- 새로운 OX TOTAL 통계창들 -->
      <div class="top-row">
        <div class="panel">
          <h3>2-1 OX TOTAL (20 rows) - <span id="ox_total_2_1_count"></span></h3>
          <div id="ox_total_2_1_grid" class="ox-grid"></div>
        </div>
        <div class="panel">
          <h3>방향그림종합 (20 rows) - <span id="direction_summary_count"></span></h3>
          <div id="direction_summary_grid" class="ox-grid"></div>
        </div>
      </div>
    </div>
  </div>

<script>
  const state = { seq: [], wide:false };
  let derivedPositiveIsRed = true;
  let oxTotalData = []; // OX TOTAL 데이터 저장 (2-2용)
  let oxTotalData2_1 = []; // 2-1 OX TOTAL 데이터 저장
  let oxDirectionData = []; // OX TOTAL 방향예측값 데이터 저장
  let directionSummaryData = []; // 방향그림종합 데이터 저장
  let currentPrediction = null; // 현재 예측값 저장
  let currentPrediction2 = null; // 예측값2 저장
  let originalPanelsHidden = false; // 기존 패널 숨김 상태
  let usePrediction2ForOX = false; // OX TOTAL에서 예측값2 사용 여부
  
  // 예측값2 통계 데이터
  let prediction2_1Stats = { total: 0, correct: 0, incorrect: 0 }; // 예측값2-1 통계
  let prediction2_2Stats = { total: 0, correct: 0, incorrect: 0 }; // 예측값2-2 통계
  let lastPrediction2_1 = null; // 마지막 예측값2-1
  let lastPrediction2_2 = null; // 마지막 예측값2-2
  let usePrediction2_2ForOX = true; // OX TOTAL에서 예측값2-2 사용 여부 (기본값: true)

  function add(x){ 
    state.seq.push(x); 
    
    // 예측값2-1은 OX TOTAL 2-1의 실제 카운트를 사용하므로 별도 통계 업데이트 불필요
    
    // 예측값2-2는 O창/X창의 실제 카운트를 사용하므로 별도 통계 업데이트 불필요
    
    
    // 예측값2-2와 비교하여 OX TOTAL에 기록
    if (usePrediction2_2ForOX && lastPrediction2_2 !== null) {
      // 예측값2-2와 비교
      const isCorrect = (x === lastPrediction2_2);
      addToOXTotal(isCorrect ? 'O' : 'X');
    } else if (!usePrediction2_2ForOX && currentPrediction !== null) {
      // 기존 예측값과 비교
      const isCorrect = (x === currentPrediction);
      addToOXTotal(isCorrect ? 'O' : 'X');
    }
    
    // 기존 예측값과 비교하여 OX TOTAL 방향예측값에 기록 (예측값이 있을 때만)
    if (currentPrediction !== null) {
      const isCorrect = (x === currentPrediction);
      addToOXDirection(isCorrect ? 'O' : 'X');
    }
    
    // 방향그림종합: 예측값과 예측값2-2가 동일할 경우만 기록
    if (currentPrediction !== null && lastPrediction2_2 !== null && currentPrediction === lastPrediction2_2) {
      const isCorrect = (x === currentPrediction);
      addToDirectionSummary(isCorrect ? 'O' : 'X');
    } else if (currentPrediction !== null && lastPrediction2_2 !== null) {
      // 예측값이 있지만 다를 경우 "-" 기록
      addToDirectionSummary('-');
    }
    
    // 각 예측값별 OX TOTAL에 기록 - 예측값이 있으면 O/X, 없으면 "-"
    if (lastPrediction2_1 !== null) {
      const isCorrect = (x === lastPrediction2_1);
      addToOXTotal2_1(isCorrect ? 'O' : 'X');
    } else {
      addToOXTotal2_1('-');
    }
    
    
    render(); 
  }
  
  function undo(){ 
    // 마지막 입력값 저장 (undo 전)
    const lastInput = state.seq[state.seq.length - 1];
    
    state.seq.pop(); 
    
    // OX TOTAL에서도 마지막 항목 제거
    if (oxTotalData.length > 0) {
      oxTotalData.pop();
    }
    
    // OX TOTAL 방향예측값에서도 마지막 항목 제거
    if (oxDirectionData.length > 0) {
      oxDirectionData.pop();
    }
    
    // 방향그림종합에서도 마지막 항목 제거
    if (directionSummaryData.length > 0) {
      directionSummaryData.pop();
    }
    
    // 각 예측값별 OX TOTAL에서도 마지막 항목 제거
    if (oxTotalData2_1.length > 0) {
      oxTotalData2_1.pop();
    }
    
    // 예측값들이 실제로 사용되었는지 확인하여 적절히 처리
    if (lastPrediction2_1 !== null && oxTotalData2_1.length > 0) {
      // 2-1이 실제로 사용되었다면 null로 초기화
      lastPrediction2_1 = null;
    }
    
    render(); 
    // OX TOTAL과 O/X 창 업데이트
    renderOXTotal();
    updateOAndXGrids();
    
    // 각 예측값별 OX TOTAL 렌더링
    renderOXTotal2_1();
    renderOXDirection();
    renderDirectionSummary();
  }
  
  function resetAll(){ 
    state.seq = []; 
    oxTotalData = []; 
    oxTotalData2_1 = [];
    oxDirectionData = [];
    directionSummaryData = [];
    currentPrediction = null;
    currentPrediction2 = null;
    
    // 통계 초기화
    prediction2_1Stats = { total: 0, correct: 0, incorrect: 0 };
    prediction2_2Stats = { total: 0, correct: 0, incorrect: 0 };
    lastPrediction2_1 = null;
    lastPrediction2_2 = null;
    
    render(); 
    // OX TOTAL과 O/X 창 업데이트
    renderOXTotal();
    updateOAndXGrids();
    
    // 각 예측값별 OX TOTAL 렌더링
    renderOXTotal2_1();
    renderOXDirection();
    renderDirectionSummary();
  }
  
  function toggleDerivedMeaning(){ derivedPositiveIsRed = !derivedPositiveIsRed; render(); }

  // 기존 패널들 토글 함수 (비활성화됨)
  function toggleOriginalPanels(){
    return; // 함수 비활성화 - 아무 동작하지 않음
    originalPanelsHidden = !originalPanelsHidden;
    usePrediction2_2ForOX = originalPanelsHidden; // 기존창이 숨겨지면 예측값2-2 사용
    const toggleBtn = document.getElementById('toggle_btn');
    
    // 숨길 패널들 (다음값예상창은 제외)
    const panelsToToggle = [
      'original_pattern', 
      'original_prediction_result',
      'original_prediction_value'
    ];
    
    panelsToToggle.forEach(id => {
      const panel = document.getElementById(id);
      if (panel) {
        panel.style.display = originalPanelsHidden ? 'none' : 'block';
      }
    });
    
    // 버튼 텍스트 변경
    if (toggleBtn) {
      toggleBtn.textContent = originalPanelsHidden ? '기존창 보이기' : '기존창 숨기기';
    }
    
    // OX TOTAL 창 제목 업데이트
    updateOXTotalTitle();
  }

  // OX TOTAL 창 제목 업데이트 함수
  function updateOXTotalTitle(){
    const oxTotalTitle = document.querySelector('#ox_total_grid').parentElement.querySelector('h3');
    if (oxTotalTitle) {
      if (usePrediction2_2ForOX) {
        oxTotalTitle.textContent = 'OX TOTAL 그림예측 (20 rows) - ';
      } else {
        oxTotalTitle.textContent = 'OX TOTAL 그림예측 (20 rows) - ';
      }
    }
  }

  // OX TOTAL에 Big Road 방식으로 추가
  function addToOXTotal(value) {
    oxTotalData.push(value);
    renderOXTotal();
    updateOAndXGrids(); // O창과 X창 업데이트
  }

  // 2-1 OX TOTAL에 Big Road 방식으로 추가
  function addToOXTotal2_1(value) {
    oxTotalData2_1.push(value);
    renderOXTotal2_1();
  }


  // OX TOTAL 방향예측값에 Big Road 방식으로 추가
  function addToOXDirection(value) {
    oxDirectionData.push(value);
    renderOXDirection();
  }

  // 방향그림종합에 Big Road 방식으로 추가
  function addToDirectionSummary(value) {
    directionSummaryData.push(value);
    renderDirectionSummary();
  }

  // OX TOTAL 그리드를 Big Road 방식으로 렌더링
  function renderOXTotal() {
    const oxTotalGrid = document.getElementById('ox_total_grid');
    if (!oxTotalGrid) return;
    
    oxTotalGrid.innerHTML = '';
    
    // Big Road 방식으로 데이터 재구성
    const ROWS = 20;
    const cols = [];
    let c = 0, r = 0;
    
    for (let i = 0; i < oxTotalData.length; i++) {
      const cur = oxTotalData[i], prev = i > 0 ? oxTotalData[i-1] : null;
      
      if (i === 0) {
        if (!cols[0]) cols[0] = [];
        cols[0][0] = cur;
        c = 0;
        r = 0;
        continue;
      }
      
      if (cur === prev) {
        if (r + 1 < ROWS && (!cols[c] || !cols[c][r+1])) {
          r = r + 1;
        } else {
          let nc = c + 1;
          while (cols[nc] && cols[nc][r]) nc++;
          c = nc;
        }
      } else {
        let nc = c + 1;
        while (cols[nc] && cols[nc][0]) nc++;
        c = nc;
        r = 0;
      }
      
      if (!cols[c]) cols[c] = [];
      cols[c][r] = cur;
    }
    
    // 렌더링
    for (let c = 0; c < cols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(${ROWS}, var(--cell))`;
      
      for (let r = 0; r < ROWS; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = cols[c] ? cols[c][r] : '';
        cell.textContent = value;
        if (value === 'O') cell.classList.add('o');
        if (value === 'X') cell.classList.add('x');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      oxTotalGrid.appendChild(colDiv);
    }
    
    // OX TOTAL의 열 구조를 저장하여 O창과 X창에서 사용
    window.oxTotalCols = cols;
  }

  // 2-1 OX TOTAL 그리드를 Big Road 방식으로 렌더링
  function renderOXTotal2_1() {
    const oxTotalGrid = document.getElementById('ox_total_2_1_grid');
    if (!oxTotalGrid) return;
    
    oxTotalGrid.innerHTML = '';
    
    // Big Road 방식으로 데이터 재구성
    const ROWS = 20;
    const cols = [];
    let c = 0, r = 0;
    
    for (let i = 0; i < oxTotalData2_1.length; i++) {
      const cur = oxTotalData2_1[i], prev = i > 0 ? oxTotalData2_1[i-1] : null;
      
      if (i === 0) {
        if (!cols[0]) cols[0] = [];
        cols[0][0] = cur;
        c = 0;
        r = 0;
        continue;
      }
      
      if (cur === prev) {
        if (r + 1 < ROWS && (!cols[c] || !cols[c][r+1])) {
          r = r + 1;
        } else {
          let nc = c + 1;
          while (cols[nc] && cols[nc][r]) nc++;
          c = nc;
        }
      } else {
        let nc = c + 1;
        while (cols[nc] && cols[nc][0]) nc++;
        c = nc;
        r = 0;
      }
      
      if (!cols[c]) cols[c] = [];
      cols[c][r] = cur;
    }
    
    // 렌더링
    for (let c = 0; c < cols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(${ROWS}, var(--cell))`;
      
      for (let r = 0; r < ROWS; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = cols[c] ? cols[c][r] : '';
        cell.textContent = value;
        if (value === 'O') cell.classList.add('o');
        if (value === 'X') cell.classList.add('x');
        if (value === '-') {
          cell.style.background = 'transparent';
          cell.style.borderColor = '#3a4661';
          cell.style.color = '#9aa3b2';
        }
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      oxTotalGrid.appendChild(colDiv);
    }
  }


  // OX TOTAL 방향예측값 그리드를 Big Road 방식으로 렌더링
  function renderOXDirection() {
    const oxDirectionGrid = document.getElementById('ox_direction_grid');
    if (!oxDirectionGrid) return;
    
    oxDirectionGrid.innerHTML = '';
    
    // Big Road 방식으로 데이터 재구성
    const ROWS = 20;
    const cols = [];
    let c = 0, r = 0;
    
    for (let i = 0; i < oxDirectionData.length; i++) {
      const cur = oxDirectionData[i], prev = i > 0 ? oxDirectionData[i-1] : null;
      
      if (i === 0) {
        if (!cols[0]) cols[0] = [];
        cols[0][0] = cur;
        c = 0;
        r = 0;
        continue;
      }
      
      if (cur === prev) {
        if (r + 1 < ROWS && (!cols[c] || !cols[c][r+1])) {
          r = r + 1;
        } else {
          let nc = c + 1;
          while (cols[nc] && cols[nc][r]) nc++;
          c = nc;
        }
      } else {
        let nc = c + 1;
        while (cols[nc] && cols[nc][0]) nc++;
        c = nc;
        r = 0;
      }
      
      if (!cols[c]) cols[c] = [];
      cols[c][r] = cur;
    }
    
    // 렌더링
    for (let c = 0; c < cols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(${ROWS}, var(--cell))`;
      
      for (let r = 0; r < ROWS; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = cols[c] ? cols[c][r] : '';
        cell.textContent = value;
        if (value === 'O') cell.classList.add('o');
        if (value === 'X') cell.classList.add('x');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      oxDirectionGrid.appendChild(colDiv);
    }
    
    // OX TOTAL 방향예측값의 열 구조를 저장하여 O창과 X창에서 사용
    window.oxDirectionCols = cols;
    
    // 방향예측값 O창과 X창 업데이트
    updateDirectionOAndXGrids();
  }

  // 방향그림종합 그리드를 Big Road 방식으로 렌더링
  function renderDirectionSummary() {
    const directionSummaryGrid = document.getElementById('direction_summary_grid');
    if (!directionSummaryGrid) return;
    
    directionSummaryGrid.innerHTML = '';
    
    // Big Road 방식으로 데이터 재구성
    const ROWS = 20;
    const cols = [];
    let c = 0, r = 0;
    
    for (let i = 0; i < directionSummaryData.length; i++) {
      const cur = directionSummaryData[i], prev = i > 0 ? directionSummaryData[i-1] : null;
      
      if (i === 0) {
        if (!cols[0]) cols[0] = [];
        cols[0][0] = cur;
        c = 0;
        r = 0;
        continue;
      }
      
      if (cur === prev) {
        if (r + 1 < ROWS && (!cols[c] || !cols[c][r+1])) {
          r = r + 1;
        } else {
          let nc = c + 1;
          while (cols[nc] && cols[nc][r]) nc++;
          c = nc;
        }
      } else {
        let nc = c + 1;
        while (cols[nc] && cols[nc][0]) nc++;
        c = nc;
        r = 0;
      }
      
      if (!cols[c]) cols[c] = [];
      cols[c][r] = cur;
    }
    
    // 렌더링
    for (let c = 0; c < cols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(${ROWS}, var(--cell))`;
      
      for (let r = 0; r < ROWS; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = cols[c] ? cols[c][r] : '';
        cell.textContent = value;
        if (value === 'O') cell.classList.add('o');
        if (value === 'X') cell.classList.add('x');
        if (value === '-') {
          cell.style.background = 'transparent';
          cell.style.borderColor = '#3a4661';
          cell.style.color = '#9aa3b2';
        }
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      directionSummaryGrid.appendChild(colDiv);
    }
  }

  // 방향예측값 O창과 X창을 OX TOTAL 방향예측값 데이터에서 각 열별로 분리하여 업데이트
  function updateDirectionOAndXGrids() {
    if (!window.oxDirectionCols) return;
    
    // OX TOTAL 방향예측값의 각 열에서 O와 X를 분리
    const oCols = [];
    const xCols = [];
    
    for (let colIndex = 0; colIndex < window.oxDirectionCols.length; colIndex++) {
      const col = window.oxDirectionCols[colIndex];
      const oCol = [];
      const xCol = [];
      let hasO = false;
      let hasX = false;
      
      for (let rowIndex = 0; rowIndex < 20; rowIndex++) {
        const value = col && col[rowIndex] ? col[rowIndex] : '';
        if (value === 'O') {
          oCol[rowIndex] = 'O';
          hasO = true;
        } else if (value === 'X') {
          xCol[rowIndex] = 'X';
          hasX = true;
        }
      }
      
      // 데이터가 있는 열만 추가
      if (hasO) {
        oCols.push(oCol);
      }
      if (hasX) {
        xCols.push(xCol);
      }
    }
    
    // 방향예측값 O창 렌더링
    renderDirectionOGrid(oCols);
    
    // 방향예측값 X창 렌더링
    renderDirectionXGrid(xCols);
  }

  // 방향예측값 O 그리드 렌더링 (빈 열 제거)
  function renderDirectionOGrid(oCols) {
    const oGrid = document.getElementById('direction_o_grid');
    if (!oGrid) return;
    
    oGrid.innerHTML = '';
    
    // 데이터가 있는 열만 표시
    for (let c = 0; c < oCols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(20, var(--cell))`;
      
      for (let r = 0; r < 20; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = oCols[c] && oCols[c][r] ? oCols[c][r] : '';
        cell.textContent = value;
        if (value === 'O') cell.classList.add('o');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      oGrid.appendChild(colDiv);
    }
  }

  // 방향예측값 X 그리드 렌더링 (빈 열 제거)
  function renderDirectionXGrid(xCols) {
    const xGrid = document.getElementById('direction_x_grid');
    if (!xGrid) return;
    
    xGrid.innerHTML = '';
    
    // 데이터가 있는 열만 표시
    for (let c = 0; c < xCols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(20, var(--cell))`;
      
      for (let r = 0; r < 20; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = xCols[c] && xCols[c][r] ? xCols[c][r] : '';
        cell.textContent = value;
        if (value === 'X') cell.classList.add('x');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      xGrid.appendChild(colDiv);
    }
  }

  // O창과 X창을 OX TOTAL 데이터에서 각 열별로 분리하여 업데이트
  function updateOAndXGrids() {
    if (!window.oxTotalCols) return;
    
    // OX TOTAL의 각 열에서 O와 X를 분리
    const oCols = [];
    const xCols = [];
    
    for (let colIndex = 0; colIndex < window.oxTotalCols.length; colIndex++) {
      const col = window.oxTotalCols[colIndex];
      const oCol = [];
      const xCol = [];
      let hasO = false;
      let hasX = false;
      
      for (let rowIndex = 0; rowIndex < 20; rowIndex++) {
        const value = col && col[rowIndex] ? col[rowIndex] : '';
        if (value === 'O') {
          oCol[rowIndex] = 'O';
          hasO = true;
        } else if (value === 'X') {
          xCol[rowIndex] = 'X';
          hasX = true;
        }
      }
      
      // 데이터가 있는 열만 추가
      if (hasO) {
        oCols.push(oCol);
      }
      if (hasX) {
        xCols.push(xCol);
      }
    }
    
    // O창 렌더링
    renderOGrid(oCols);
    
    // X창 렌더링
    renderXGrid(xCols);
  }

  // O 그리드 렌더링 (빈 열 제거)
  function renderOGrid(oCols) {
    const oGrid = document.getElementById('o_grid');
    if (!oGrid) return;
    
    oGrid.innerHTML = '';
    
    // 데이터가 있는 열만 표시
    for (let c = 0; c < oCols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(20, var(--cell))`;
      
      for (let r = 0; r < 20; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = oCols[c] && oCols[c][r] ? oCols[c][r] : '';
        cell.textContent = value;
        if (value === 'O') cell.classList.add('o');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      oGrid.appendChild(colDiv);
    }
  }

  // X 그리드 렌더링 (빈 열 제거)
  function renderXGrid(xCols) {
    const xGrid = document.getElementById('x_grid');
    if (!xGrid) return;
    
    xGrid.innerHTML = '';
    
    // 데이터가 있는 열만 표시
    for (let c = 0; c < xCols.length; c++) {
      const colDiv = document.createElement('div');
      colDiv.className = 'ox-col';
      colDiv.style.gridTemplateRows = `repeat(20, var(--cell))`;
      
      for (let r = 0; r < 20; r++) {
        const cell = document.createElement('div');
        cell.className = 'ox-cell';
        const value = xCols[c] && xCols[c][r] ? xCols[c][r] : '';
        cell.textContent = value;
        if (value === 'X') cell.classList.add('x');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      xGrid.appendChild(colDiv);
    }
  }

  // 우측 보드만 스케일 조정: 의존 변수까지 함께 갱신
  function setScale(v){
    const board = document.getElementById('board');
    if (board){
      board.style.setProperty('--ui-scale', String(v));
      board.style.setProperty('--cell', `calc(var(--cell-base) * ${v})`);
      board.style.setProperty('--gap', `calc(6px * ${v})`);
    }
    render();
  }

  function buildBigRoad(seq, maxRows=20){
    const cols = [];
    let c = 0, r = 0;
    const cellAt = (x,y)=> cols[x] && cols[x][y];
    const ensureCol = (x)=>{ while(!cols[x]) cols[x] = []; };
    for (let i=0;i<seq.length;i++){
      const cur = seq[i], prev = i>0 ? seq[i-1] : null;
      if (i===0){ ensureCol(0); cols[0][0] = cur; c=0; r=0; continue; }
      if (cur === prev){
        if (r+1 < maxRows && !cellAt(c, r+1)) r = r+1;
        else { let nc = c+1; while (cellAt(nc, r)) nc++; c = nc; }
      } else {
        let nc = c+1; while (cols[nc] && cols[nc][0]) nc++; c = nc; r = 0;
      }
      ensureCol(c); cols[c][r] = cur;
    }
    return cols;
  }

  // 중국점 도트 생성: r==0 표준 높이 비교, r>0 특별규칙(오프셋 기준)
  function buildDerivedDots(bigRoadCols, offset){
    const height = (x)=> (bigRoadCols[x] ? bigRoadCols[x].filter(Boolean).length : 0);
    const exists = (x,y)=> !!(bigRoadCols[x] && bigRoadCols[x][y]);

    const dots = [];
    for (let c=0; c<bigRoadCols.length; c++){
      const col = bigRoadCols[c] || [];
      for (let r=0; r<col.length; r++){
        if (!col[r]) continue;

        const started = (c > offset) || (c === offset && r >= 1);
        if (!started) continue;

        let positive;
        if (r === 0){
          positive = (height(c-1) === height(c-1-offset));
        } else {
          const currentHas = true;
          const lastHas = exists(c, r-1);
          const refSame = exists(c - offset, r);
          const refPrev = exists(c - offset, r-1);

          const currentPatternSame = (currentHas === lastHas);
          const refPatternSame = (refSame === refPrev);

          positive = (currentPatternSame && refPatternSame) || (!currentPatternSame && !refPatternSame);
        }

        const isRed = derivedPositiveIsRed ? positive : !positive;
        dots.push(isRed ? 'R' : 'B');
      }
    }
    return dots;
  }

  function placeDotsAsBigRoad(dots, maxRows=20){
    const cols = [];
    let c=0, r=0;
    const cellAt = (x,y)=> cols[x] && cols[x][y];
    const ensureCol = (x)=>{ while(!cols[x]) cols[x]=[]; };

    for (let i=0;i<dots.length;i++){
      const cur = dots[i], prev = i>0 ? dots[i-1] : null;
      if (i===0){ ensureCol(0); cols[0][0] = cur; c=0; r=0; continue; }
      if (cur === prev){
        if (r+1 < maxRows && !cellAt(c, r+1)) r = r+1;
        else { let nc = c+1; while (cellAt(nc, r)) nc++; c = nc; }
      } else {
        let nc = c+1; while (cols[nc] && cols[nc][0]) nc++; c = nc; r = 0;
      }
      ensureCol(c); cols[c][r] = cur;
    }
    return cols;
  }

  function buildDerived(bigRoadCols, offset, rows=20){
    const dots = buildDerivedDots(bigRoadCols, offset);
    return placeDotsAsBigRoad(dots, rows);
  }

  function renderCols(container, cols, rows){
    container.innerHTML = '';
    for (let c=0;c<cols.length;c++){
      const colDiv = document.createElement('div');
      colDiv.className = 'col';
      colDiv.style.gridTemplateRows = `repeat(${rows}, var(--cell))`;
      for (let r=0;r<rows;r++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        const v = cols[c] ? cols[c][r] : null;
        if (v==='B') cell.classList.add('fill-b');
        if (v==='P') cell.classList.add('fill-p');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      container.appendChild(colDiv);
    }
  }

  function renderDerived(container, cols, rows){
    container.innerHTML = '';
    for (let c=0;c<cols.length;c++){
      const colDiv = document.createElement('div');
      colDiv.className = 'col';
      colDiv.style.gridTemplateRows = `repeat(${rows}, var(--cell))`;
      for (let r=0;r<rows;r++){
        const cell = document.createElement('div');
        cell.className = 'dcell';
        const v = cols[c] ? cols[c][r] : null;
        if (v==='R') cell.classList.add('d-red');
        if (v==='B') cell.classList.add('d-blue');
        colDiv.appendChild(cell);
        
        // 6행, 12행, 18행 밑에 구분선 추가
        if (r === 5 || r === 11 || r === 17) {
          const divider = document.createElement('div');
          divider.className = 'row-divider';
          divider.style.gridColumn = '1 / -1';
          divider.style.gridRow = `${r + 2} / ${r + 3}`;
          colDiv.appendChild(divider);
        }
      }
      container.appendChild(colDiv);
    }
  }

  function computePredictionDot(candidate, offset){
    const seq2 = state.seq.concat(candidate);
    const big2 = buildBigRoad(seq2, 20);
    const dots2 = buildDerivedDots(big2, offset);
    if (dots2.length === 0) return null;
    return dots2[dots2.length - 1];
  }

  function setPredUI(idBase, val){
    const dot = document.getElementById(idBase + '_dot');
    const arrow = document.getElementById(idBase + '_arrow');
    if (!dot) return;
    
    dot.style.background = 'transparent';
    dot.style.borderColor = '#2a3448';
    if (arrow) arrow.textContent = '';
    
    if (val === 'R'){
      dot.style.background = 'var(--red)';
      dot.style.borderColor = 'var(--red)';
    } else if (val === 'B'){
      dot.style.background = 'var(--blue)';
      dot.style.borderColor = 'var(--blue)';
    }
  }

  // 새로운 함수: 예상값과 현재값 비교하여 화살표 표시
  function setPredictionArrow(idBase, predictedVal, currentVal){
    const arrow = document.getElementById(idBase + '_arrow');
    if (!arrow) return;
    
    if (predictedVal === null || currentVal === null) {
      arrow.textContent = '';
      return;
    }
    
    if (predictedVal === currentVal) {
      arrow.textContent = '⬇'; // 하향화살표 (같음)
    } else {
      arrow.textContent = '➡'; // 우향화살표 (다름)
    }
  }

  function setPatternArrow(elId, same){
    const el = document.getElementById(elId);
    if (!el){ return; }
    if (same === null){
      el.textContent = '-';
      return;
    }
    el.textContent = same ? '⬇' : '➡';
  }

  function computePatternSame(dots){
    if (!dots || dots.length < 2) return null;
    const cur = dots[dots.length - 1];
    const prev = dots[dots.length - 2];
    return cur === prev;
  }

  function setPredictionResult(id, predictedVal){
    const el = document.getElementById(id);
    if (!el) return;
    
    el.textContent = '-';
    el.className = 'prediction-badge neutral';
    
    if (predictedVal === 'P'){
      el.textContent = 'P';
      el.classList.add('p');
    } else if (predictedVal === 'B'){
      el.textContent = 'B';
      el.classList.add('b');
    }
  }

  // 새로운 예측값창 업데이트 함수
  function setPredictionValueDisplay(predictedVal){
    const el = document.getElementById('pred_value_display');
    if (!el) return;
    
    el.textContent = '-';
    el.className = 'prediction-badge neutral';
    
    if (predictedVal === 'P'){
      el.textContent = 'P';
      el.classList.add('p');
    } else if (predictedVal === 'B'){
      el.textContent = 'B';
      el.classList.add('b');
    }
  }

  // 패턴분석2창 - 현재 색상 표시 함수
  function setCurrentColorDisplay(id, color){
    const el = document.getElementById(id);
    if (!el) return;
    
    el.textContent = '-';
    el.className = 'prediction-badge neutral';
    
    if (color === 'R'){
      el.textContent = 'R';
      el.style.background = 'var(--red)';
      el.style.color = '#fff';
    } else if (color === 'B'){
      el.textContent = 'B';
      el.style.background = 'var(--blue)';
      el.style.color = '#fff';
    }
  }

  // Cockroach Pig 값이 처음 나왔는지 확인하는 함수
  function hasCockroachStarted(){
    const dots_ck = buildDerivedDots(buildBigRoad(state.seq, 20), 3);
    return dots_ck.length > 0;
  }

  // 예측값2-1 (3개 모두 일치) 계산 함수
  function calculatePrediction2_1(currentColors, nextPColors, nextBColors){
    // Cockroach Pig가 시작되지 않았으면 null 반환
    if (!hasCockroachStarted()) {
      return null;
    }
    
    // 유효한 색상이 있는지 확인
    const validCurrent = currentColors.filter(color => color !== null);
    const validNextP = nextPColors.filter(color => color !== null);
    const validNextB = nextBColors.filter(color => color !== null);
    
    if (validCurrent.length < 3 || validNextP.length < 3 || validNextB.length < 3) {
      return null;
    }
    
    // 각 패턴별로 현재 색상과 Next P/B 색상 비교
    let pMatchCount = 0;
    let bMatchCount = 0;
    
    for (let i = 0; i < 3; i++) {
      if (currentColors[i] === nextPColors[i]) {
        pMatchCount++;
      }
      if (currentColors[i] === nextBColors[i]) {
        bMatchCount++;
      }
    }
    
    // 3개가 모두 일치할 때만 예측값 반환
    if (pMatchCount === 3) {
      return 'P';
    } else if (bMatchCount === 3) {
      return 'B';
    } else {
      return null;
    }
  }

  // 예측값2-2 (2개 이상 일치) 계산 함수
  function calculatePrediction2_2(currentColors, nextPColors, nextBColors){
    // Cockroach Pig가 시작되지 않았으면 null 반환
    if (!hasCockroachStarted()) {
      return null;
    }
    
    // 유효한 색상이 있는지 확인
    const validCurrent = currentColors.filter(color => color !== null);
    const validNextP = nextPColors.filter(color => color !== null);
    const validNextB = nextBColors.filter(color => color !== null);
    
    if (validCurrent.length < 3 || validNextP.length < 3 || validNextB.length < 3) {
      return null;
    }
    
    // 현재 색상에서 2개 이상인 색상 찾기
    const colorCount = { 'R': 0, 'B': 0 };
    for (let i = 0; i < 3; i++) {
      if (currentColors[i] === 'R') colorCount['R']++;
      if (currentColors[i] === 'B') colorCount['B']++;
    }
    
    // 2개 이상인 색상이 없으면 null 반환
    if (colorCount['R'] < 2 && colorCount['B'] < 2) {
      return null;
    }
    
    // Next P에서 2개 이상인 색상 찾기
    const nextPColorCount = { 'R': 0, 'B': 0 };
    for (let i = 0; i < 3; i++) {
      if (nextPColors[i] === 'R') nextPColorCount['R']++;
      if (nextPColors[i] === 'B') nextPColorCount['B']++;
    }
    
    // Next B에서 2개 이상인 색상 찾기
    const nextBColorCount = { 'R': 0, 'B': 0 };
    for (let i = 0; i < 3; i++) {
      if (nextBColors[i] === 'R') nextBColorCount['R']++;
      if (nextBColors[i] === 'B') nextBColorCount['B']++;
    }
    
    // 현재 색상이 2개 이상인 색상과 Next P/B에서 2개 이상인 색상이 같은지 확인
    let pMatch = false;
    let bMatch = false;
    
    // R이 2개 이상인 경우
    if (colorCount['R'] >= 2) {
      if (nextPColorCount['R'] >= 2) pMatch = true;
      if (nextBColorCount['R'] >= 2) bMatch = true;
    }
    
    // B가 2개 이상인 경우
    if (colorCount['B'] >= 2) {
      if (nextPColorCount['B'] >= 2) pMatch = true;
      if (nextBColorCount['B'] >= 2) bMatch = true;
    }
    
    // 매치 결과에 따라 예측값 반환
    if (pMatch && !bMatch) {
      return 'P';
    } else if (bMatch && !pMatch) {
      return 'B';
    } else if (pMatch && bMatch) {
      // 둘 다 매치되는 경우 P 우선
      return 'P';
    } else {
      return null;
    }
  }


  // 예측값2-1 표시 함수
  function setPredictionValue2_1Display(currentColors, nextPColors, nextBColors){
    const el = document.getElementById('pred_value2_1_display');
    const infoEl = document.getElementById('prediction2_1_info');
    
    if (!el || !infoEl) return;
    
    const previousPrediction = currentPrediction2; // 이전 예측값 저장
    
    // 예측값2-1 계산 (3개 모두 일치)
    const prediction2_1 = calculatePrediction2_1(currentColors, nextPColors, nextBColors);
    
    el.textContent = '-';
    el.className = 'prediction-badge neutral';
    
    if (prediction2_1 === 'P') {
      el.textContent = 'P';
      el.style.background = 'var(--blue)';
      el.style.color = '#fff';
      infoEl.textContent = `P 완전 일치: 3/3`;
      currentPrediction2 = 'P';
      lastPrediction2_1 = 'P';
      
      // 새로운 예측값이 나타났을 때 알람소리 재생
      if (previousPrediction !== 'P') {
        playPredictionAlert();
      }
    } else if (prediction2_1 === 'B') {
      el.textContent = 'B';
      el.style.background = 'var(--red)';
      el.style.color = '#fff';
      infoEl.textContent = `B 완전 일치: 3/3`;
      currentPrediction2 = 'B';
      lastPrediction2_1 = 'B';
      
      // 새로운 예측값이 나타났을 때 알람소리 재생
      if (previousPrediction !== 'B') {
        playPredictionAlert();
      }
    } else {
      if (!hasCockroachStarted()) {
        infoEl.textContent = `Cockroach Pig 시작 대기 중...`;
      } else {
        infoEl.textContent = `3개 일치 없음`;
      }
      currentPrediction2 = null;
      lastPrediction2_1 = null;
    }
  }

  // 예측값2-2 표시 함수
  function setPredictionValue2_2Display(currentColors, nextPColors, nextBColors){
    const el = document.getElementById('pred_value2_2_display');
    const infoEl = document.getElementById('prediction2_2_info');
    
    if (!el || !infoEl) return;
    
    // 예측값2-2 계산 (2개 이상 일치)
    const prediction2_2 = calculatePrediction2_2(currentColors, nextPColors, nextBColors);
    
    el.textContent = '-';
    el.className = 'prediction-badge neutral';
    
    if (prediction2_2 === 'P') {
      el.textContent = 'P';
      el.style.background = 'var(--blue)';
      el.style.color = '#fff';
      infoEl.textContent = `P 2개 이상 일치`;
      lastPrediction2_2 = 'P';
    } else if (prediction2_2 === 'B') {
      el.textContent = 'B';
      el.style.background = 'var(--red)';
      el.style.color = '#fff';
      infoEl.textContent = `B 2개 이상 일치`;
      lastPrediction2_2 = 'B';
    } else {
      if (!hasCockroachStarted()) {
        infoEl.textContent = `Cockroach Pig 시작 대기 중...`;
      } else {
        infoEl.textContent = `2개 이상 일치 없음`;
      }
      lastPrediction2_2 = null;
    }
  }


  // 통계 표시 함수
  function updateStatisticsDisplay(){
    // 예측값2-1 통계 표시 - OX TOTAL 2-1의 실제 카운트와 동일하게 ("-" 제외)
    const stats2_1El = document.getElementById('stats2_1_display');
    if (stats2_1El) {
      const oCount2_1 = oxTotalData2_1.filter(x => x === 'O').length;
      const xCount2_1 = oxTotalData2_1.filter(x => x === 'X').length;
      const totalCount2_1 = oCount2_1 + xCount2_1; // "-" 제외한 실제 예측값만
      const accuracy = totalCount2_1 > 0 ? 
        Math.round((oCount2_1 / totalCount2_1) * 100) : 0;
      stats2_1El.textContent = `총:${totalCount2_1} O:${oCount2_1} X:${xCount2_1} (${accuracy}%)`;
    }
    
    // 예측값2-2 통계 표시 - O창/X창의 실제 카운트와 동일하게
    const stats2_2El = document.getElementById('stats2_2_display');
    if (stats2_2El) {
      const oCount = oxTotalData.filter(x => x === 'O').length;
      const xCount = oxTotalData.filter(x => x === 'X').length;
      const totalCount = oxTotalData.length;
      const accuracy = totalCount > 0 ? 
        Math.round((oCount / totalCount) * 100) : 0;
      stats2_2El.textContent = `총:${totalCount} O:${oCount} X:${xCount} (${accuracy}%)`;
    }
    
  }

  // 예측값 통계 업데이트 함수
  function updatePredictionStats(){
    const predictionStatsEl = document.getElementById('prediction_stats');
    if (predictionStatsEl) {
      const oCount = oxDirectionData.filter(x => x === 'O').length;
      const xCount = oxDirectionData.filter(x => x === 'X').length;
      const totalCount = oCount + xCount; // "-" 제외한 실제 예측값만
      const accuracy = totalCount > 0 ? 
        Math.round((oCount / totalCount) * 100) : 0;
      predictionStatsEl.textContent = `총:${totalCount} O:${oCount} X:${xCount} (${accuracy}%)`;
    }
  }

  // 그림방향통계 업데이트 함수
  function updateDirectionSummaryStats(){
    const directionSummaryStatsEl = document.getElementById('direction_summary_stats_display');
    if (directionSummaryStatsEl) {
      const oCount = directionSummaryData.filter(x => x === 'O').length;
      const xCount = directionSummaryData.filter(x => x === 'X').length;
      const totalCount = oCount + xCount; // "-" 제외한 실제 예측값만
      const accuracy = totalCount > 0 ? 
        Math.round((oCount / totalCount) * 100) : 0;
      directionSummaryStatsEl.textContent = `총:${totalCount} O:${oCount} X:${xCount} (${accuracy}%)`;
    }
  }

  // 예측값 알람소리 재생 함수 (자명종소리)
  function playPredictionAlert(){
    try {
      // Web Audio API를 사용한 자명종소리 생성
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // 자명종소리 패턴: 두 개의 주파수를 번갈아가며 재생
      const duration = 2.0; // 2초간 재생
      const startTime = audioContext.currentTime;
      
      // 첫 번째 주파수 (800Hz)
      const oscillator1 = audioContext.createOscillator();
      const gainNode1 = audioContext.createGain();
      oscillator1.connect(gainNode1);
      gainNode1.connect(audioContext.destination);
      
      oscillator1.frequency.setValueAtTime(800, startTime);
      oscillator1.type = 'sine';
      
      // 두 번째 주파수 (1000Hz)
      const oscillator2 = audioContext.createOscillator();
      const gainNode2 = audioContext.createGain();
      oscillator2.connect(gainNode2);
      gainNode2.connect(audioContext.destination);
      
      oscillator2.frequency.setValueAtTime(1000, startTime);
      oscillator2.type = 'sine';
      
      // 자명종 패턴: 0.2초마다 번갈아가며 재생
      for (let i = 0; i < duration * 2.5; i++) {
        const time = startTime + i * 0.2;
        const isFirst = i % 2 === 0;
        
        if (isFirst) {
          // 첫 번째 주파수 재생
          gainNode1.gain.setValueAtTime(0, time);
          gainNode1.gain.linearRampToValueAtTime(0.5, time + 0.05);
          gainNode1.gain.linearRampToValueAtTime(0, time + 0.15);
          
          gainNode2.gain.setValueAtTime(0, time);
        } else {
          // 두 번째 주파수 재생
          gainNode2.gain.setValueAtTime(0, time);
          gainNode2.gain.linearRampToValueAtTime(0.5, time + 0.05);
          gainNode2.gain.linearRampToValueAtTime(0, time + 0.15);
          
          gainNode1.gain.setValueAtTime(0, time);
        }
      }
      
      oscillator1.start(startTime);
      oscillator2.start(startTime);
      oscillator1.stop(startTime + duration);
      oscillator2.stop(startTime + duration);
      
    } catch (error) {
      // Web Audio API가 지원되지 않는 경우 대체 알람
      console.log('예측값 자명종 알람!');
    }
  }

  // 새로운 함수: 패턴 분석의 화살표를 기반으로 예측
  function computePatternPrediction(patternArrows, nextPArrows, nextBArrows){
    const patternInfo = document.getElementById('pattern_info');
    
    if (!patternInfo) return;
    
    // 화살표가 null이 아닌 것들만 필터링
    const validArrows = patternArrows.filter(arrow => arrow !== null);
    
    if (validArrows.length < 3) {
      patternInfo.textContent = '패턴 분석 중...';
      setPredictionValueDisplay(null);
      currentPrediction = null;
      return;
    }
    
    const downCount = validArrows.filter(arrow => arrow === true).length; // ⬇ (같음)
    const rightCount = validArrows.filter(arrow => arrow === false).length; // ➡ (다름)
    
    // 모든 패턴이 같은 방향인 경우
    if (downCount === 3 || rightCount === 3) {
      const allSameDirection = downCount === 3 ? true : false; // true면 모두 하향, false면 모두 우향
      patternInfo.textContent = `모든 패턴이 같은 방향 (${allSameDirection ? '⬇' : '➡'})`;
      
      // Next P 라인과 Next B 라인에서 해당 방향의 화살표 개수 세기
      const validNextPArrows = nextPArrows.filter(arrow => arrow !== null);
      const validNextBArrows = nextBArrows.filter(arrow => arrow !== null);
      
      let nextPSameCount = 0;
      let nextBSameCount = 0;
      
      // Next P 라인에서 같은 방향의 화살표 개수
      for (let i = 0; i < validNextPArrows.length; i++) {
        if (validNextPArrows[i] === allSameDirection) {
          nextPSameCount++;
        }
      }
      
      // Next B 라인에서 같은 방향의 화살표 개수
      for (let i = 0; i < validNextBArrows.length; i++) {
        if (validNextBArrows[i] === allSameDirection) {
          nextBSameCount++;
        }
      }
      
      // 더 많은 쪽을 선택
      if (nextPSameCount > nextBSameCount) {
        setPredictionValueDisplay('P');
        currentPrediction = 'P';
      } else if (nextBSameCount > nextPSameCount) {
        setPredictionValueDisplay('B');
        currentPrediction = 'B';
      } else {
        setPredictionValueDisplay(null);
        currentPrediction = null;
      }
    }
    // 2개가 같은 방향이고 1개가 다른 방향인 경우 (기존 로직)
    else if ((downCount === 2 && rightCount === 1) || (downCount === 1 && rightCount === 2)) {
      // 어떤 패턴이 다른지 찾기
      const patternNames = ['Big Eye', 'Small Road', 'Cockroach Pig'];
      let differentPattern = '';
      let differentPatternIndex = -1;
      let differentDirection = null;
      
      if (downCount === 2 && rightCount === 1) {
        // 2개가 하향, 1개가 우향
        for (let i = 0; i < patternArrows.length; i++) {
          if (patternArrows[i] === false) { // 우향화살표
            differentPattern = patternNames[i];
            differentPatternIndex = i;
            differentDirection = false; // 우향
            break;
          }
        }
      } else {
        // 2개가 우향, 1개가 하향
        for (let i = 0; i < patternArrows.length; i++) {
          if (patternArrows[i] === true) { // 하향화살표
            differentPattern = patternNames[i];
            differentPatternIndex = i;
            differentDirection = true; // 하향
            break;
          }
        }
      }
      
      patternInfo.textContent = `${differentPattern}이 다른 방향 (${differentDirection ? '⬇' : '➡'})`;
      
      // 해당 패턴의 Next P 라인에서의 화살표와 비교
      if (differentPatternIndex >= 0 && nextPArrows[differentPatternIndex] !== null) {
        const nextPArrow = nextPArrows[differentPatternIndex];
        
        if (nextPArrow === differentDirection) {
          // Next P 라인의 화살표가 패턴의 현재 방향과 같으면 "B"
          setPredictionValueDisplay('B');
          currentPrediction = 'B';
        } else {
          // Next P 라인의 화살표가 패턴의 현재 방향과 다르면 "P"
          setPredictionValueDisplay('P');
          currentPrediction = 'P';
        }
      } else {
        setPredictionValueDisplay(null);
        currentPrediction = null;
      }
    } else {
      patternInfo.textContent = '패턴이 일치하지 않음';
      setPredictionValueDisplay(null);
      currentPrediction = null;
    }
  }

  function render(){
    const ROWS = 20;
    const big = buildBigRoad(state.seq, ROWS);
    renderCols(document.getElementById('bigroad'), big, ROWS);

    const bigEye = buildDerived(big, 1, ROWS);
    const small  = buildDerived(big, 2, ROWS);
    const cock   = buildDerived(big, 3, ROWS);

    renderDerived(document.getElementById('bigeye'), bigEye, ROWS);
    renderDerived(document.getElementById('smallroad'), small, ROWS);
    renderDerived(document.getElementById('cockroach'), cock, ROWS);

    // 현재 중국점 값들 가져오기
    const dots_be = buildDerivedDots(big, 1);
    const dots_sm = buildDerivedDots(big, 2);
    const dots_ck = buildDerivedDots(big, 3);
    
    const current_be = dots_be.length > 0 ? dots_be[dots_be.length - 1] : null;
    const current_sm = dots_sm.length > 0 ? dots_sm[dots_sm.length - 1] : null;
    const current_ck = dots_ck.length > 0 ? dots_ck[dots_ck.length - 1] : null;

    // Predictions
    const p_be = computePredictionDot('P', 1);
    const p_sm = computePredictionDot('P', 2);
    const p_ck = computePredictionDot('P', 3);
    const b_be = computePredictionDot('B', 1);
    const b_sm = computePredictionDot('B', 2);
    const b_ck = computePredictionDot('B', 3);

    setPredUI('predP_be', p_be);
    setPredUI('predP_sm', p_sm);
    setPredUI('predP_ck', p_ck);
    setPredUI('predB_be', b_be);
    setPredUI('predB_sm', b_sm);
    setPredUI('predB_ck', b_ck);

    // 예상값과 현재값 비교하여 화살표 표시
    setPredictionArrow('predP_be', p_be, current_be);
    setPredictionArrow('predP_sm', p_sm, current_sm);
    setPredictionArrow('predP_ck', p_ck, current_ck);
    setPredictionArrow('predB_be', b_be, current_be);
    setPredictionArrow('predB_sm', b_sm, current_sm);
    setPredictionArrow('predB_ck', b_ck, current_ck);

    // Pattern analysis arrows
    const pattern_be = computePatternSame(dots_be);
    const pattern_sm = computePatternSame(dots_sm);
    const pattern_ck = computePatternSame(dots_ck);
    
    setPatternArrow('ptr_be', pattern_be);
    setPatternArrow('ptr_sm', pattern_sm);
    setPatternArrow('ptr_ck', pattern_ck);

    // Next P 라인과 Next B 라인의 화살표들 (예상값과 현재값 비교 결과)
    const nextP_be_arrow = p_be === current_be; // true면 ⬇, false면 ➡
    const nextP_sm_arrow = p_sm === current_sm;
    const nextP_ck_arrow = p_ck === current_ck;
    
    const nextB_be_arrow = b_be === current_be; // true면 ⬇, false면 ➡
    const nextB_sm_arrow = b_sm === current_sm;
    const nextB_ck_arrow = b_ck === current_ck;

    // 패턴 예측 결과 표시
    computePatternPrediction([pattern_be, pattern_sm, pattern_ck], [nextP_be_arrow, nextP_sm_arrow, nextP_ck_arrow], [nextB_be_arrow, nextB_sm_arrow, nextB_ck_arrow]);

    // 패턴분석2창 - 현재 색상 표시
    setCurrentColorDisplay('current_color_be', current_be);
    setCurrentColorDisplay('current_color_sm', current_sm);
    setCurrentColorDisplay('current_color_ck', current_ck);

    // 예측값2-1창 - 색상 비교하여 예측값 표시
    setPredictionValue2_1Display([current_be, current_sm, current_ck], [p_be, p_sm, p_ck], [b_be, b_sm, b_ck]);
    
    // 예측값2-2창 - 색상 비교하여 예측값 표시
    setPredictionValue2_2Display([current_be, current_sm, current_ck], [p_be, p_sm, p_ck], [b_be, b_sm, b_ck]);
    
    // 통계 표시 업데이트
    updateStatisticsDisplay();
    
    // 예측값 통계 업데이트
    updatePredictionStats();
    
    // 그림방향통계 업데이트
    updateDirectionSummaryStats();

    const b = state.seq.filter(x=>x==='B').length;
    const p = state.seq.filter(x=>x==='P').length;
    document.getElementById('count').textContent = `B: ${b} | P: ${p} | Total: ${state.seq.length}`;
    
    // Big Road 카운트 업데이트
    const bigroadCount = document.getElementById('bigroad_count');
    if (bigroadCount) {
      bigroadCount.textContent = `B: ${b} | P: ${p} | Total: ${state.seq.length}`;
    }
    
    // OX TOTAL 카운트 업데이트
    const oxTotalCount = document.getElementById('ox_total_count');
    if (oxTotalCount) {
      const oCount = oxTotalData.filter(x => x === 'O').length;
      const xCount = oxTotalData.filter(x => x === 'X').length;
      oxTotalCount.textContent = `O: ${oCount} | X: ${xCount} | Total: ${oxTotalData.length}`;
    }
    
    // OX TOTAL 방향예측값 카운트 업데이트
    const oxDirectionCount = document.getElementById('ox_direction_count');
    if (oxDirectionCount) {
      const oCount = oxDirectionData.filter(x => x === 'O').length;
      const xCount = oxDirectionData.filter(x => x === 'X').length;
      oxDirectionCount.textContent = `O: ${oCount} | X: ${xCount} | Total: ${oxDirectionData.length}`;
    }
    
    // O창과 X창 카운트 업데이트
    const oCount = document.getElementById('o_count');
    const xCount = document.getElementById('x_count');
    if (oCount) {
      const oCountValue = oxTotalData.filter(x => x === 'O').length;
      oCount.textContent = oCountValue;
    }
    if (xCount) {
      const xCountValue = oxTotalData.filter(x => x === 'X').length;
      xCount.textContent = xCountValue;
    }
    
    // 방향예측값 O창과 X창 카운트 업데이트
    const directionOCount = document.getElementById('direction_o_count');
    const directionXCount = document.getElementById('direction_x_count');
    if (directionOCount) {
      const directionOCountValue = oxDirectionData.filter(x => x === 'O').length;
      directionOCount.textContent = directionOCountValue;
    }
    if (directionXCount) {
      const directionXCountValue = oxDirectionData.filter(x => x === 'X').length;
      directionXCount.textContent = directionXCountValue;
    }
    
    // 방향그림종합 카운트 업데이트
    const directionSummaryCount = document.getElementById('direction_summary_count');
    if (directionSummaryCount) {
      const oCount = directionSummaryData.filter(x => x === 'O').length;
      const xCount = directionSummaryData.filter(x => x === 'X').length;
      const totalCount = oCount + xCount; // "-" 제외한 실제 예측값만
      directionSummaryCount.textContent = `O: ${oCount} | X: ${xCount} | Total: ${totalCount}`;
    }
    
    // 각 예측값별 OX TOTAL 카운트 업데이트
    const oxTotal2_1Count = document.getElementById('ox_total_2_1_count');
    if (oxTotal2_1Count) {
      const oCount2_1 = oxTotalData2_1.filter(x => x === 'O').length;
      const xCount2_1 = oxTotalData2_1.filter(x => x === 'X').length;
      const totalCount2_1 = oCount2_1 + xCount2_1; // "-" 제외한 실제 예측값만
      oxTotal2_1Count.textContent = `O: ${oCount2_1} | X: ${xCount2_1} | Total: ${totalCount2_1}`;
    }
    
    
    // Big Eye, Small Road, Cockroach Pig의 긍정/부정 갯수 표시
    const bigeyeCount = document.getElementById('bigeye_count');
    if (bigeyeCount) {
      const redCount_be = dots_be.filter(x => x === 'R').length;
      const blueCount_be = dots_be.filter(x => x === 'B').length;
      bigeyeCount.textContent = `긍정: ${redCount_be} | 부정: ${blueCount_be} | Total: ${dots_be.length}`;
    }
    
    const smallroadCount = document.getElementById('smallroad_count');
    if (smallroadCount) {
      const redCount_sm = dots_sm.filter(x => x === 'R').length;
      const blueCount_sm = dots_sm.filter(x => x === 'B').length;
      smallroadCount.textContent = `긍정: ${redCount_sm} | 부정: ${blueCount_sm} | Total: ${dots_sm.length}`;
    }
    
    const cockroachCount = document.getElementById('cockroach_count');
    if (cockroachCount) {
      const redCount_ck = dots_ck.filter(x => x === 'R').length;
      const blueCount_ck = dots_ck.filter(x => x === 'B').length;
      cockroachCount.textContent = `긍정: ${redCount_ck} | 부정: ${blueCount_ck} | Total: ${dots_ck.length}`;
    }
    
    // 패턴분석2창의 긍정/부정 갯수 표시
    const pattern2BeCount = document.getElementById('pattern2_be_count');
    if (pattern2BeCount) {
      const redCount_be = dots_be.filter(x => x === 'R').length;
      const blueCount_be = dots_be.filter(x => x === 'B').length;
      const totalCount_be = dots_be.length;
      const positivePercent = totalCount_be > 0 ? Math.round((redCount_be / totalCount_be) * 100) : 0;
      pattern2BeCount.innerHTML = `토탈: ${totalCount_be}개 | 긍정: ${redCount_be}개 | 부정: ${blueCount_be}개 | <span class="percentage-bold">(${positivePercent}%)</span>`;
    }
    
    const pattern2SmCount = document.getElementById('pattern2_sm_count');
    if (pattern2SmCount) {
      const redCount_sm = dots_sm.filter(x => x === 'R').length;
      const blueCount_sm = dots_sm.filter(x => x === 'B').length;
      const totalCount_sm = dots_sm.length;
      const positivePercent = totalCount_sm > 0 ? Math.round((redCount_sm / totalCount_sm) * 100) : 0;
      pattern2SmCount.innerHTML = `토탈: ${totalCount_sm}개 | 긍정: ${redCount_sm}개 | 부정: ${blueCount_sm}개 | <span class="percentage-bold">(${positivePercent}%)</span>`;
    }
    
    const pattern2CkCount = document.getElementById('pattern2_ck_count');
    if (pattern2CkCount) {
      const redCount_ck = dots_ck.filter(x => x === 'R').length;
      const blueCount_ck = dots_ck.filter(x => x === 'B').length;
      const totalCount_ck = dots_ck.length;
      const positivePercent = totalCount_ck > 0 ? Math.round((redCount_ck / totalCount_ck) * 100) : 0;
      pattern2CkCount.innerHTML = `토탈: ${totalCount_ck}개 | 긍정: ${redCount_ck}개 | 부정: ${blueCount_ck}개 | <span class="percentage-bold">(${positivePercent}%)</span>`;
    }
  }

  // PWA 설치 기능
  let deferredPrompt;
  let installButton;

  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    
    // 설치 버튼 생성
    if (!installButton) {
      installButton = document.createElement('button');
      installButton.textContent = '앱 설치';
      installButton.className = 'install-btn';
      installButton.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        background: #3498db;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 5px;
        font-weight: bold;
        z-index: 1000;
        cursor: pointer;
      `;
      
      installButton.addEventListener('click', async () => {
        if (deferredPrompt) {
          deferredPrompt.prompt();
          const { outcome } = await deferredPrompt.userChoice;
          console.log(`User response to the install prompt: ${outcome}`);
          deferredPrompt = null;
          installButton.style.display = 'none';
        }
      });
      
      document.body.appendChild(installButton);
    }
  });

  window.addEventListener('appinstalled', () => {
    console.log('PWA was installed');
    if (installButton) {
      installButton.style.display = 'none';
    }
  });

  // Service Worker 등록
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/sw.js')
        .then((registration) => {
          console.log('SW registered: ', registration);
        })
        .catch((registrationError) => {
          console.log('SW registration failed: ', registrationError);
        });
    });
  }

  // 초기 렌더링
  render();
  renderOXTotal();
  updateOAndXGrids();
  renderOXTotal2_1();
  renderOXDirection();
  renderDirectionSummary();
  updateOXTotalTitle(); // 초기 OX TOTAL 제목 설정
</script>
</body>
</html>